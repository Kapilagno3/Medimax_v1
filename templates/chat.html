<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>MediBot Chat</title>
	<link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
	<!-- Fallback when opening this file directly via file:// ‚Äî replaced only if template not rendered -->
	<script>
		(function(){
			try{
				const link = document.querySelector('link[rel="stylesheet"]');
				if(link && link.getAttribute('href') && link.getAttribute('href').includes('{')){
					// replace with a relative path to the static folder for quick local testing
					link.setAttribute('href','../static/style.css');
				}
			}catch(e){/* noop */}
		})();
	</script>
</head>
<body>
	<main class="chat-app">
		<header class="chat-header">
			<div class="title">MediBot</div>
			<button id="theme-toggle" class="theme-toggle" aria-label="Toggle light and dark mode">
				<span class="icon sun">‚òÄÔ∏è</span>
				<span class="icon moon">üåô</span>
			</button>
		</header>

		<section id="messages" class="messages" aria-live="polite">
			{% if messages %}
				{% for message in messages %}
					{% if message.role == 'user' %}
						<div class="message-row user">
							<div class="bubble">{{ message.text }}</div>
						</div>
					{% else %}
						<div class="message-row bot">
							<div class="bubble">{{ message.text }}</div>
						</div>
					{% endif %}
				{% endfor %}
			{% else %}
				<div class="empty">Start the conversation ‚Äî ask MediBot a question.</div>
			{% endif %}
		</section>

		<form class="composer" method="POST" action="/get" autocomplete="off">
			<textarea name="user_input" id="user_input" class="input" placeholder="Type a message..." rows="1" required></textarea>
			<button type="submit" class="send" aria-label="Send message">Send</button>
		</form>
	</main>

	<script>
		// Theme toggle and persistence
		const body = document.body;
		const toggle = document.getElementById('theme-toggle');
		const storageKey = 'medibot-theme';

		function applyTheme(mode) {
			if (mode === 'dark') body.classList.add('dark-mode');
			else body.classList.remove('dark-mode');
		}

		// initialize
		let theme = localStorage.getItem(storageKey) || (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
		applyTheme(theme);

		toggle.addEventListener('click', () => {
			theme = body.classList.contains('dark-mode') ? 'light' : 'dark';
			applyTheme(theme);
			localStorage.setItem(storageKey, theme);
		});

		// Auto-resize textarea
		const textarea = document.getElementById('user_input');
		function resize() {
			textarea.style.height = 'auto';
			textarea.style.height = textarea.scrollHeight + 'px';
		}
		textarea.addEventListener('input', resize);
		window.addEventListener('load', resize);

		// Auto-scroll messages to bottom when new nodes are added
		const messages = document.getElementById('messages');
		function scrollToBottom() {
			messages.scrollTop = messages.scrollHeight;
		}

		// Scroll on load (if any messages)
		window.addEventListener('load', () => setTimeout(scrollToBottom, 50));

		// Observe for dynamic changes (if backend pushes new content via re-rendering or JS)
		const observer = new MutationObserver(() => scrollToBottom());
		observer.observe(messages, { childList: true, subtree: true });

		const form = document.querySelector('.composer');
        const inputField = document.getElementById('user_input');
        
        // Helper function to create a new message bubble in the DOM
        function createMessageElement(text, role) {
            const row = document.createElement('div');
            row.className = `message-row ${role}`;
            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            bubble.textContent = text;
            row.appendChild(bubble);
            return row;
        }

        async function handleFormSubmission(event) {
            // CHANGE 4: PREVENT the default page refresh
            event.preventDefault(); 

            const userInput = inputField.value.trim();

            if (!userInput) return; // Prevent submission of empty messages

            // 1. Display user message immediately
            messages.appendChild(createMessageElement(userInput, 'user'));
            inputField.value = ''; // Clear input field

            // Add a temporary 'typing...' message
            const botThinking = createMessageElement('MediBot is typing...', 'bot');
            botThinking.id = 'thinking';
            messages.appendChild(botThinking);
            scrollToBottom(); 
            
            // 2. Send data to Flask backend
            const formData = new FormData();
            // CHANGE 5: Append the data with the correct key: "user_input"
            formData.append('user_input', userInput); 

            try {
                const response = await fetch('/get', {
                    method: 'POST',
                    body: formData // Fetch handles Content-Type for FormData
                });

                // 3. Process the response
                const result = await response.json();
                
                // Remove the 'thinking' message
                document.getElementById('thinking').remove();

                if (response.ok) {
                    messages.appendChild(createMessageElement(result.response, 'bot'));
                } else {
                    // Handle error state (e.g., 400 error from app.py)
                    messages.appendChild(createMessageElement('Error: ' + result.response, 'bot'));
                }
                
            } catch (error) {
                console.error('Fetch error:', error);
                document.getElementById('thinking').remove();
                messages.appendChild(createMessageElement('A network error occurred.', 'bot'));
            }
            scrollToBottom();
        }

        // CHANGE 6: Attach the new submission handler
        form.addEventListener('submit', handleFormSubmission);
	</script>
</body>
</html>
